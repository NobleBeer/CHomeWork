#include <time.h>     // библиотека работы с таймером
#include <stdio.h>    // библиотека ввода-вывода
#include <stdlib.h>   // библиотека системных функций
#include <locale.h>   // библиотека языковой локализации
#include <cmath>


//  Тестовый план в виде набора статических константных массивов
static const int test1[] = { 22, -14, 52, -17, 86, 24, 72, -23 }; 
static const int test2[] = { 32, 2, -4, 64, -8, 16, 8, 4 };          
static const int test3[] = { -53, -3, -92, -31, -89, 56, -54, 0 };         // для характеристики
static const int test4[] = { 23, 53, -28, -90, -10, -40, 34, 37, -66, 41, 39, 4 }; // сортировочки
static const int test5[] = { 22, -14, 52, -17, 86, 24, 72, -23 };        // для переворота
static const int test6[] = { 8 };                                    // одно значение
//  Массив указателей на тестовые массивы
static const int* tests[] = { test1, test2, test3, test4, test5, test6 };
//  Массив размеров тестовых массивов
static const int  sizes[] = {
 sizeof(test1) / sizeof(int), sizeof(test2) / sizeof(int),
 sizeof(test3) / sizeof(int), sizeof(test4) / sizeof(int),
 sizeof(test5) / sizeof(int), sizeof(test6) / sizeof(int) };
//  Количество тестовых массивов
static const int maxtest = sizeof(sizes) / sizeof(int);
//  Длина имени файла
static const int length = 66;
//  Предельный размер массива
static const int maxsize = 999;
//  Диапазон для случайных значений
static const int minrand = 8;
static const int maxrand = 180;

#pragma warning(disable: 4996)

static long Sv(int n)
{
    if (n == 1)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 1;
    return Sv(n - 3) + Sv(n - 2) + Sv(n - 1);
}
static bool isProperty(int n)
{
    if ((n == 1) || (n == 0))  return true;
    if (n < 0) n = -n;

    int a = 0;
    int b = 1;
    int c = 1;
    for (int i = 2; i <= n; i += a + b)
    {
        a = b;
        b = c;
        c = i;
        if (i == n)
        {
            return true;
        }
    }
    return false;
}


/*
   Главная функция. Реализует ввод, проверку, интерфейс с пользователем.
*/
void main()
{
    char ch = '?';                    // Команда меню
    int  index, state;                // Индекс элемента в массиве 
    int  value, check;                // Число для ввода и статус проверки
    int  range = 100;                 // Диапазон случайных чисел
    int  size = 0;                    // Размер текущего массива
    int kk = 0;
    char chr = '%';
    int Sch;
    int Sn;
    int max = -1000;

    int* mass = NULL;                 // Указатель на текущий динамический массив
    char filename[length];            // Имя файла
    FILE* fp;                         // Указатель на файловой поток
    FILE* out;


    // Для сообщений на русском языке
    setlocale(LC_ALL, "Russian");
    printf("Лаба: Перестановка элементов");
    // Инициализация генератора случайных чисел
    srand((unsigned int)time(NULL));

    do {                              // Обработка команд меню
        switch (ch)
        {
        case 'C':     // Ввод размера и резервирование массива
        case 'c':
            // Ввести новый размер массива и проверить корректность ввода
            printf("\nВведите размер массива [1..%d]:>", maxsize);
            check = scanf("%d", &value);

            // Проверить корректность ввода и допустимость диапазона
            if (check != 1 || fgetchar() != 10 || value < 1 || value > maxsize)
            {
                printf("Ошибка: Некорректный размер массива\n");
                break;
            }

            // Если массив зарезервирован, то удалить текущий массив
            if (size != 0)
            {
                delete[] mass;
                size = 0;
            }

            // Зарезервировать память под массив для заданного размера
            mass = new int[value];

            // Убедиться, что память выделена
            if (mass == NULL)
            {
                printf("Ошибка: Недостаточно памяти для резервирования\n");
                break;
            }
            // Запомнить новый размер
            size = value;
            // Перейти к заполнению текущего массива

       

        case 'R':     // Заполнение массива случайными значениями
        case 'r':
            // Перемещаться по элементам массива 
            for (index = 0; index < size; index++)
                // Генерировать и запоминать случайные значения
                mass[index] = ((rand() % 2) ? +1 : -1) * (rand() % range);
            // Перейти к отображению текущего массива


        case 'P':     // Печать элементов массива
        case 'p':
            printf("\nТекущий массив [%d] %s\n", size, ((size) ? "содержит:" : "пуст"));
            // Перемещаться по элементам массива
            for (index = 0; index < size; index++)
                // Выводить значения элементов массива
                printf("Элемент[%d]=%d \n", index, mass[index]);
            break;



        case 'D':     // Удаление массива
        case 'd':
            // Если массив зарезервирован, то удалить текущий массив
            if (size != 0) delete[] mass;
            // Обнулить размер и вывести, что массив пуст
            size = 0;
            printf("\nМассив пуст!");
            break;


        case 'V':     // Заполнение массива заданным значением
        case 'v':
            // Проверить, что массив не пуст, т.е. есть что изменять
            if (size == 0) break;

            // Ввести значение и проверить корректность ввода
            printf("\nВведите значение:>");
            check = scanf("%d", &value);

            // Проверить корректность ввода
            if (check != 1 || fgetchar() != 10)
            {
                printf("Ошибка: Некорректный ввод\n");
                break;
            }
            // Перемещаться по элементам массива и сохранять значение
            for (index = 0; index < size; index++)
                mass[index] = value;
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case 'T':     // Копирование тестового массива
        case 't':
            // Ввести номер теста и проверить корректность ввода
            printf("\nВведите номер теста [1..%d]:>", maxtest);
            check = scanf("%d", &value);

            // Проверить корректность ввода и номера теста
            if (check != 1 || fgetchar() != 10 || value < 1 || value > maxtest)
            {
                printf("Ошибка: Некорректный номер теста\n");
                break;
            }

            // Если массив зарезервирован, то удалить текущий массив
            if (size != 0) delete[] mass;

            // Зарезервировать память под массив такого же размера как тестовый массив
            mass = new int[(size = sizes[--value])];

            // Убедиться, что память выделена
            if (mass == NULL) size = 0;
            else
                // Копировать элементы тестового массива в текущий массив
                for (index = 0; index < size; index++)
                    mass[index] = (tests[value])[index];

            // Перейти к отображению текущего массива
            ch = 'P';
            continue;


        case 'E':     // Ввод всех элементов массива по порядку
        case 'e':
            // Перемещаться по элементам массива 
            for (index = 0; index < size; index++)
            {
                // Вводить новые значения для элементов массива
                printf("\nВведите элемент[%d]:>", index);
                check = scanf("%d", &mass[index]);
                // Проверить корректность ввода и вернуть индекс 
                // на последний некорректный элемент массива
                if (check != 1 || fgetchar() != 10) index--;
                // иначе перейти к следующему элементу
            }
            break;

        case 'Y': // Печать элементов массива в строчку через запятую
       // Перемещаться по элементам массива
            for (index = 0; index < size; index++)
                // Выводить значения элементов массива
                printf("%d, ", mass[index]);
            break;

        case 'H':
        case 'h':
            for (int index = 0; index < size; index++) 
            {
                if (max < mass[index]) 
                {
                    max = mass[index];
                }
            }
            if (size % 2 == 0)
            {
                if (max % 2 == 0)
                {
                    for (index = 1; index < size / 2; index += 2)
                    {

                        value = mass[index];
                        mass[index] = mass[size - index];
                        mass[size - index] = value;
                    }
                }           
                else
                {
                    for (index = 0; index < size / 2; index += 2)
                    {

                        value = mass[index];
                        mass[index] = mass[size - index - 2];
                        mass[size - index - 2] = value;
                    }
                }
            }
            else 
            {
                if (max % 2 == 0)
                {
                    // Перемещаться по элементам массива от первого до середины
                    for (index = 0; index < size / 2 - 1; index += 2)
                    {
                        // Переставить местами элемент под текущим индексом и 
                        // элемент, зеркально расположенный к нему от середины
                        value = mass[index];
                        mass[index] = mass[size - index - 1];
                        mass[size - index - 1] = value;
                    }
                }
                if (max % 2 != 0)
                {
                    // Перемещаться по элементам массива от первого до середины
                    for (index = 1; index < size / 2; index += 2)
                    {
                        // Переставить местами элемент под текущим индексом и 
                        // элемент, зеркально расположенный к нему от середины
                        value = mass[index];
                        mass[index] = mass[size - index - 1];
                        mass[size - index - 1] = value;
                    }
                }
            }
            break;

        case 'M':     // Изменение элемента массива по индексу
        case 'm':
            // Проверить, что массив не пуст, т.е. есть что изменять
            if (size == 0) break;

            // Ввести индекс элемента для изменения и проверить корректность ввода
            printf("\nВведите индекс элемента [0..%d]:>", size - 1);
            check = scanf("%d", &index);

            // Проверить корректность ввода и допустимость диапазона индексов
            if (check != 1 || fgetchar() != 10 || index < 0 || index >= size)
            {
                printf("Ошибка: Некорректный индекс\n");
                break;
            }

            // Ввести новое значение элемента и проверить корректность ввода
            printf("\nВведите значение элемента:>");
            check = scanf("%d", &value);

            // Проверить корректность ввода
            if (check != 1 || fgetchar() != 10)
            {
                printf("Ошибка: Некорректный ввод\n");
                break;
            }

            // Запомнить новое значение в элементе массива
            mass[index] = value;
            printf("Элемент изменен!\n");
            break;


        case 'S':        // Сохранение массива в файле
        case 's':
        case 'Z':
        case 'z':
        case 'B':
        case 'b':
        case 'U':
        case 'u':
            while (getchar() != '\n' && getchar() != EOF);
            // Ввести имя файла
            printf("\nВведите имя файла для сохранения (или нажмите [enter] для отмены):>");
            // if(*gets_s(filename, length) == '\0') break;
            scanf("%s", filename);

            // Создать файл для сохранения массива
            if ((fp = fopen(filename, "w")) == NULL)
                printf("\nОшибка: Файл с указанным именем не может создан или открыт на запись\n");
            else
            {
                if (ch == 'b' || ch == 'B')
                {
                    // Записать размер массива в бинарный файл
                    fwrite(&size, sizeof(int), 1, fp);
                    // Записать элементы массива в бинарный файл как единый блок
                    if (size != 0) fwrite(mass, sizeof(int), size, fp);
                }
                else if (ch == 's' || ch == 'S')
                {
                    // Записать размер массива в текстовый файл
                    fprintf(fp, "%d", size);
                    // Записать элементы массива в текстовый файл поштучно
                    for (index = 0; index < size; index++)
                        fprintf(fp, " %d", mass[index]);
                }
                else if (ch == 'z' || ch == 'Z')
                {
                    int predel;
                    printf("Введите верхнее значение:>");
                    scanf("%d", &predel);
                    for (kk = 1; Sv(kk) <= predel; kk++)
                        fprintf(fp, "%d\n", Sv(kk));
                }
                else if (ch == 'u' || ch == 'U')
                {
                    fprintf(fp, "%d", size);
                    for (index = 0; index < size; index++)
                    {
                        if (index == 0)
                            fprintf(fp, "%c%d%c ", chr, mass[index], chr);
                        else
                            fprintf(fp, ": %c%d%c ", chr, mass[index], chr);
                    }
                }
                // Закрыть файл
                fclose(fp);
                printf("\nМассив сохранен успешно\n");
            }
            break;


        case 'L': // Загрузка массива из файла
        case 'l':
        case 'O':
        case 'o':
            //fflush(stdin);
            while (getchar() != '\n');
            // Ввести имя файла
            printf("\nВведите имя файл для загрузки (или нажмите [enter] для отмены):>");
            //if(*gets_s(filename, length) == '\0') break;
            scanf("%s", filename);
            // Открыть файл для загрузки массива

            if ((fp = fopen(filename, "r")) == NULL)
                printf("\nОшибка: Файл с указанным именем не может быть открыт на чтение\n");
            else
            {
                if (ch == 'o' || ch == 'O')
                    // Прочитать размер массива из бинарного файла
                    check = fread(&value, sizeof(int), 1, fp);
                else if (ch == 'l' || ch == 'L')
                    // Прочитать размер массива из текстового файла
                    check = fscanf(fp, "%d", &value);
                // Проверить корректность чтения размера
                if (check == 1)
                {
                    // Проверить допустимость диапазона значений для размера
                    if (value >= 1 && value <= maxsize)
                    {
                        // Если имеется текущий зарезервированный массив, то удалить его
                        if (size != 0) delete[] mass;
                        // Зарезервировать память под новый массив и запомнить его размер
                        mass = new int[(size = value)];
                        // Убедиться, что память выделена
                        if (mass != NULL)
                        {
                            if (ch == 'o' || ch == 'O')
                                // Прочитать элементы массива из бинарного файла как единый блок
                                check = fread(mass, sizeof(int), size, fp);
                            else if (ch == 'l' || ch == 'L')
                                // Прочитать элементы массива из текстового файла поштучно
                                for (check = 0, index = 0; index < size; index++, check++)
                                    if (fscanf(fp, "%d", &mass[index]) != 1) break;
                            if (check == size)
                            {
                                // Массив загружен успешно
                                printf("\nМассив загружен успешно\n");
                                // Закрыть файл
                                fclose(fp);
                                // Перейти к отображению текущего массива
                                ch = 'P';
                                continue;
                            }
                            // Удалить массив, в случае неудачи
                            else delete[] mass;
                        }
                        size = 0;
                    }
                }
                // Если прочитать массив не удалось
                printf("\nОшибка: Некорректные данные в файле (загрузка отменена)\n");
                // Закрыть файл
                fclose(fp);
            }
            break;


        case 'I':     // Сдвиг элементов массива влево
        case 'i':
            // Сохранить крайний левый элемент массива в переменной
            value = mass[0];
            // Перемещаться по элементам массива от второго до последнего
            for (index = 1; index < size; index++)
                // Сохранять следующий элемент в предыдущем элементе массива
                mass[index - 1] = mass[index];
            // Сохранить элемент из переменной в крайнем правом элементе 
            mass[size - 1] = value;
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case 'J':     // Сдвиг элементов массива вправо
        case 'j':
            // Сохранить крайний правый элемент массива в переменной
            value = mass[size - 1];
            // Перемещаться по элементам массива от последнего до второго
            for (index = size - 1; index > 0; index--)
                // Сохранять предыдущий элемент в следующем элементе массива
                mass[index] = mass[index - 1];
            // Сохранить элемент из переменной в крайнем левом элементе 
            mass[0] = value;
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case 'K':     // Переворот элементов массива наоборот
        case 'k':
            // Перемещаться по элементам массива от первого до середины
            for (index = 0; index < size / 2; index++)
            {
                // Переставить местами элемент под текущим индексом и 
                // элемент, зеркально расположенный к нему от середины
                value = mass[index];
                mass[index] = mass[size - index - 1];
                mass[size - index - 1] = value;
            }
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case 'W':     // Перестановка местами соседних элементов массива
        case 'w':
            // Перемещаться по элементам массива от второго до последнего
            for (index = 1; index < size; index += 2)
            {
                // Переставить местами соседние элементы 
                value = mass[index];
                mass[index] = mass[index - 1];
                mass[index - 1] = value;
            }
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;



        case 'N':     // Минимум и максимум из элементов массива
        case 'n':
            // Принять первый элемент массива за минимум и за максимум
            value = check = mass[0];
            // Перемещаться по элементам массива от второго до последнего
            for (index = 1; index < size; index++)
            {
                // Если элемент меньше минимума, то принять его за минимум  
                if (value > mass[index]) value = mass[index];
                // Если элемент больше максимума, то принять его за максимум 
                if (check < mass[index]) check = mass[index];
            }
            // Отобразить результаты
            printf("\nМинимум = %d \nМаксимум = %d\n", value, check);
            break;


        case 'X':     // Переставить элементы массива случайным образом
        case 'x':
            for (index = state = size - 1; index > 0; state--, index--)
            {
                // Выбросить случайное число, которое является номером переставляемого элемента
                check = (rand() % state);
                // Переставить местами текущий элемент и элемент со случайным номером 
                value = mass[index];
                mass[index] = mass[check];
                mass[check] = value;
            }
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case 'A':     // Настройка диапазона случайных значений
        case 'a':
            // Ввести ширину диапазона и проверить корректность ввода
            printf("\nВведите диапазон случайных чисел [%d..%d]:>", minrand, maxrand);
            check = scanf("%d", &value);

            // Проверить корректность ввода и допустимоть диапазона
            if (check != 1 || fgetchar() != 10 || value < minrand || value > maxrand)
            {
                printf("Ошибка: Некорректный диапазон\n");
                break;
            }
            // Запомнить новое значение диапазона
            range = value;
            printf("Диапазон изменен!\n");
            break;


        case 'F':     // Вычисление характеристики массива по заданию
        case 'f':
            if (size > 1)
            {
                Sch = 0;
                Sn = 0;
                for (int i = 0; i < size; i++)
                {
                    if (i % 2 == 0) Sch += mass[i];
                    else Sn += mass[i];
                }
                printf("\nОтношение = %.2f", float(Sn) / float(Sch));
            }
            else printf("\nОтношение = 1");
            break; 


        case '0':     // Сортировка элементов по убыванию без учёта свойства (0000)
        case '1':     // Сортировка элементов по возрастанию без учёта свойства (0001)
        case '4':     // Сортировка элементов по убыванию и числа со свойством слева (0100)
        case '5':     // Сортировка элементов по возрастанию и числа со свойством слева (0101)
        case '6':     // Сортировка элементов по убыванию и числа со свойством справа (0110)
        case '7':     // Сортировка элементов по возрастанию и числа со свойством справа (0111)
          // Проверить, что в массиве есть что переставлять
            if (size < 2)
            {
                printf("\nНедостаточно элементов для сортировки!");
                break;
            }
            // Преобразование кода цифрового символа в число
            ch = ch - '0';
            /* Сортировка элементов массива по значению без учёта свойства */
            /* (~~~0) - по убыванию, (~~~1) - по возрастанию               */
            // Перемещаться по элементам от первого до предпоследнего
            for (index = 0; index < size - 1; index++)
                // Перемещаться по элементам от следующего до последнего
                for (check = index + 1; check < size; check++)
                    // Проверять условие сортировки сравнением элементов
                    if ((ch & 0x01) ? mass[index] > mass[check]  /* по возрастанию */
                        : mass[index] < mass[check]  /* по убыванию */
                        )
                    {
                        // Переставить элементы местами
                        value = mass[index];
                        mass[index] = mass[check];
                        mass[check] = value;
                    }
            /* Проверить, нужно ли учитывать свойство элементов */
            /* (~0~~) - без учёта, (~1~~) - с учётом свойства   */
            if (ch & 0x04)
            {
                /* Перемещение элементов влево или вправо в зависимости от свойства      */
                /* (~~0~) - числа со свойством слева, (~~1~) - числа со свойством справа */
            }
            // Перейти к отображению текущего массива
            ch = 'Y';
            continue;


        case '8': // Печать элементов массива, обладающих свойством
// Перемещаться по элементам массива
            for (index = 0; index < size; index++)
                // Проверить элемент на наличие свойства
                if (isProperty(mass[index]))
                    // Вывести значения элемента
                    printf("%d, ", mass[index]);
            break;


        case '?':     // Отобразить главное меню
            printf("\n\nГлавное меню:");
            printf("\nP. Печать массива");
            printf("\nU. Печать массива в строку в файл");
            printf("\nC. Создание нового массива");
            printf("\nD. Удаление текущего массива");
            printf("\nE. Ввод всех элементов массива");
            printf("\nT. Копирование тестового массива");
            printf("\nI. Сдвиг элементов массива влево");
            printf("\nJ. Сдвиг элементов массива вправо");
            printf("\nF. Вычисление характеристики массива");
            printf("\nA. Настройка диапазона случайных чисел");
            printf("\nB. Сохранение массива в бинарном файле");
            printf("\nO. Загрузка массива из бинарного файла");
            printf("\nS. Сохранение массива в текстовом файле");
            printf("\nL. Загрузка массива из текстового файла");
            printf("\nK. Переворот элементов массива наоборот");
            printf("\nM. Изменение элемента массива по индексу");
            printf("\nV. Заполнение массива заданным значением");
            printf("\nZ. Печать элементов, обладающих свойством");
            printf("\nW. Перестановка соседних элементов массива");
            printf("\nN. Минимум и максимум из элементов массива");
            printf("\nR. Заполнение массива случайными значениями");
            printf("\nX. Перестановка элементов случайным образом");
            printf("\nH. Сдвиг массива");
            printf("\nZ. Печать ряда в столбик до заданного верхнего значения в заданный файл");
            printf("\n0. Сортировка элементов по убыванию без учёта свойства");
            printf("\n1. Сортировка элементов по возрастанию без учёта свойства");
            printf("\n4. Сортировка элементов по убыванию и числа со свойством слева");
            printf("\n5. Сортировка элементов по возрастанию и числа со свойством слева");
            printf("\n6. Сортировка элементов по убыванию и числа со свойством справа");
            printf("\n7. Сортировка элементов по возрастанию и числа со свойством справа");
            printf("\nQ. Выход");
            break;

        case '\0':    // Пустое действие
            break;

        default:
            printf("Ошибка: Некорректная операция");
        };
        // Сбросить устройство ввода
        while (getchar() != '\n');
        printf("\nВыберите пункт:>");
        ch = getchar();
    } while ((ch != 'Q') && (ch != 'q'));

    // Освободить память из под текущего массива
    if (size != 0) delete[] mass;
}

