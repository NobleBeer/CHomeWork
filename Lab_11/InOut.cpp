#include <io.h>       // библиотека для работы с файловой системой
#include <stdio.h>    // библиотека ввода-вывода
#include "Task.h"     // описание глобальных данных и функций проекта
#include <iostream>

#pragma warning(disable: 4996)
/*
   Декларация списка ошибок как массива строк
*/
const char* errDescription[] = {
  "",
  "Недостаточно памяти",
  "Некорректный размер массива",
  "Некорректное значение элемента",
  "Отсутствуют элементы",
  "Файл не может быть открыт",
  "Значение не может быть сохранено",
  "Некорректное имя файла",
  "Файл уже существует",
  "Файл не найден",
  "Файл доступен только для чтения",
  "Файл доступен только для записи",
  "Некорректное значение индекса",
  "Некорректно заданное устройство в пути",
  "Обратный слеш указан несколько раз подряд",
  "Недопустимый символ в имени файла"
};
/*
   Функция печатает сообщение об ошибке
*/
void Error(errCode err  /* код ошибки */)
{
    if (err) printf("\nОшибка %d: %s", err, errDescription[err]);
}
/*
   Функция проверяет корректность размера массива
*/
bool CorrectSize(int size  /* размер */)
{
    return (size >= 1 && size <= MAXSIZE);
}


/*   Функция запрашивает подтверждение на ввод чего-либо
*/
bool Repeat()
{
    // Предложить ввести заново
    printf("\n[Enter]-Повторить ввод:>");
    // Сбросить устройство ввода
    fflush(stdin);
    // Проверить на нажатие [enter]
    return (getchar() == 10);
}
/*
   Функция реализует интерфейс для удаления массива
*/
void DeleteArray(double*& mass  /* ссылка на указатель на массив */,
    int& size      /* ссылка на размер массива */)
{
    // Проверить наличие зарезервированной области памяти
    if (mass != NULL) delete[] mass;
    // Обнулить данные о массиве
    mass = NULL;
    size = 0;
}
/*
   Функция реализует интерфейс для создания нового массива
   Фнкция запрашивает размер массива, резервирует память под
   новый массив, удаляет старый массив, инициализирует элементы
*/
void CreateArray(double*& mass  /* ссылка на указатель на массив */,
    int& size      /* ссылка на размер массива */)
{
    double* newMass = NULL;    // Указатель на новый массив
    int newSize = 0;           // Размер нового массива
    int index, check;          // Индекс элемента и статус ввода

    do {
        // Ввести размер массива
        printf("\nВведите размер масссива:>");
        check = scanf("%d", &newSize);

        // Проверить корректность ввода и допустимость значения размера
        if (check != 1 || fgetchar() != 10 || !CorrectSize(newSize))
        {
            // Вывести сообщение об ошибке, если размер некорректный
            Error(errArraySize);
            // Запросить подтверждение повторного ввода
            if (!Repeat()) return;
            // Значение введено некорректно, повторить ввод
            check = 0;
        }
        else check = 1;  // Значение введено корректно
    } while (check != 1);

    // Зарезервировать память под новый массив
    newMass = new double[newSize];

    // Проверить, что память выделена
    if (newMass == NULL)
    {
        // Вывести сообщение об ошибке, если памяти нет
        Error(errNotMemory);
        // Завершить, если памяти нет
        return;
    }
    // Удалить старый массив, если резервирование успешно
    DeleteArray(mass, size);

    // Запомнить новый указатель и размер массива как текущий
    mass = newMass;
    size = newSize;

    // Инициализировать элементы массива нулями
    for (index = 0; index < size; index++) mass[index] = 0.0;
}
/*
   Функция реализует интерфейс для создания и инициализации тестового массива
*/
void TestArray(double*& mass  /* ссылка на указатель на массив */,
    int& size      /* ссылка на размер массива */)
{
    // Статический массив с тестовыми значениями
    static double test[] = { 2.6, 0.1, 1.2, -4.5, 3.1, 8.5, 9.3, -9.8, 0.2, -1.0, 8.2, -5.4 };

    // Освободить память из под текущего массива
    if (mass != NULL) delete[] mass;

    // Вычислить размер тестового массива
    size = sizeof(test) / sizeof(double);

    // Зарезервировать память под новый массив
    if ((mass = new double[size]) != NULL)
        // Организовать цикл для копирования элементов тестового массива в новый массив  
        for (int i = 0; i < size; i++)
            // Копировать элемент
            mass[i] = test[i];
}
/*
   Функция реализует интерфейс для печати всех элементов массива подряд
*/
void ShowArray(double* mass  /* указатель на массив */,
    int size      /* размер массива */)
{
    if (mass != NULL && size > 0)
    {
        printf("\nТекущий массив (%d):\n", size);
        // Перебирать все элементы массива
        for (int index = 0; index < size; index++)
            // Вывести текущий элемент
            printf("%lg ; ", mass[index]);
        // Отделить вывод пустой строкой
        printf("\n");
    }
    // Напечатать, что массив пуст
    else printf("\nМассив пуст!\n");
}
/*
   Функция реализует интерфейс для ввода всех элементов массива подряд
*/
void ReadArray(double* mass  /* указатель на массив */,
    int size      /* размер массива */)
{
    int index, check;          // Индекс и статус ввода


    // Перебирать все элементы массива
    for (index = 0; index < size; index++)
    {
        // Ввести очередной элемент массива
        printf("\nЭлемент[%d]:>", index);
        check = scanf("%lg", &mass[index]);

        // Проверить корректность ввода
        if (check != 1 || fgetchar() != 10)
        {
            // Вывести сообщение об ошибке
            Error(errArrayElement);
            // Запросить подтверждение повторного ввода
            if (Repeat())
                // Вернуться к предыдущему элементу, если ввод
                index--;
            // Завершить ввод, если отмена
            else return;
        }
        // Перейти к следующему элементу в массиве
    }
}
/*
   Функция реализует интерфейс для изменения элементов массива по индексу
*/
void EditArray(double* mass  /* указатель на массив */,
    int size      /* размер массива */)
{
    int index, check;          // Индекс и статус ввода
    double value;              // Значение элемента

    do {
        // Ввести индекс элемента
        printf("\nВведите индекс элемента [0..%d]:>", size - 1);
        check = scanf("%d", &index);

        // Проверить корректность ввода индекса и допустимость диапазона
        if (check != 1 || fgetchar() != 10 || index < 0 || index >= size)
        {
            // Вывести сообщение об ошибке
            Error(errArrayIndex);
            // Перейти к запросу подтверждения ввода
            continue;
        }

        // Ввести значение элемента
        printf("\nВведите значение элемента [=%lg]:>", mass[index]);
        check = scanf("%lg", &value);

        // Проверить корректность ввода значения
        if (check != 1 || fgetchar() != 10)
        {
            // Вывести сообщение об ошибке
            Error(errArrayElement);
            // Перейти к запросу подтверждения ввода
            continue;
        }
        // Сохранить новое значение элемента по индексу
        mass[index] = value;
        // Вывести результат изменения
        printf("Элемент[%d] = %lg", index, mass[index]);
    }
    // Продолжать цикл, пока есть подтверждение ввода
    while (Repeat());
}
/*
   Функция реализует интерфейс для сохранения элементов массива в
   файла и обрабатывает ситуации при открытии файла и записи данных
*/
void SaveArray(double* mass  /* указатель на массив */,
    int size      /* размер массива */)
{
    errCode err;               // Код ошибки
    char filename[NAMELEN];    // Имя файла

    do {
        // Ввести имя файла
        printf("\nВведите имя файла для сохранения (или нажмите [enter] для отмены):>");
        fflush(stdin);
        scanf("%s", filename);
        if (*filename == '\0') return;

        // Проверить корректность имени файла
        if ((err = CheckFileName(filename)) == errOK)
        {
            // Проверить отсутствие файла с таким именем
            if (_access(filename, 0) == 0)
            {
                // Предложить перезаписать файл, если файл с таким именем присутствует
                printf("\nФайл уже существует. [Enter]-Перезаписать его?");
                fflush(stdin);
                char YN;
                std::cin >> YN;
                if (YN == 'N' || YN == 'n') return;

                // Проверить, что файл не имеет атрибута "read-only"
                if (_access(filename, 6) != 0)
                {
                    // Вывести сообщение об ошибке, если файл "read-only"
                    Error(errFileIsReadOnly);
                    // Перейти к подтверждению ввода
                    continue;
                }
                // Если файл существует и "read-write", то его можно перезаписывать
            }
            // Если файл не существует, то можно создать новый файл

            // Записать массив в файл
            if ((err = SaveArrayData(mass, size, filename)) == errOK)
            {
                printf("\nМассив сохранен успешно\n");
                return;
            }
        }
        // Вывести сообщение об ошибке
        Error(err);
    }
    // Продолжать цикл, пока есть подтверждение ввода
    while (Repeat());
}
/*
   Функция реализует интерфейс для загрузки элементов массива из
   файла и обрабатывает ситуации при открытии файла и чтении данных
*/
void LoadArray(double*& mass  /* ссылка на указатель на массив */,
    int& size      /* ссылка на размер массива */)

{
    errCode err;               // Код ошибки
    char filename[NAMELEN];    // Имя файла

    do {
        // Ввести имя файла
        printf("\nВведите имя файл для загрузки (или нажмите [enter] для отмены):>");
        fflush(stdin);
        scanf("%s", filename);
        if (*filename == '\0') return;

        // Проверить корректность имени файла
        if ((err = CheckFileName(filename)) == errOK)
        {
            // Проверить существование файла с таким именем
            if (_access(filename, 0) != 0) err = errFileNotFound;

            // Загрузить массив из файла с проверкой корректности данных
            else if ((err = LoadArrayData(mass, size, filename)) == errOK)
            {
                printf("\nМассив загружен успешно\n");
                return;
            }
        }
        // Вывести сообщение об ошибке
        Error(err);
    }
    // Продолжать цикл, пока есть подтверждение ввода
    while (Repeat());
}
/*
   Функция реализует интерфейс для поиска оптимальных последовательностей
   элементов по критерию
*/
void CalcArray(double* mass  /* указатель на массив */,
    int size      /* размер массива */)
{
    unsigned char ch = '9';    // Пункт подменю
    int  check;                // Статус ввода
    int  left, right;          // Начальный и конечный индексы последовательности
    //double criteriaCh;           // Оптимальное значение критерия последовательности
    //double criteriaN;
    double criteria;

    do {
        switch (ch)
        {
        case '1':     // Печать всех элементов массива
            ShowArray(mass, size);
            break;

        //case '2':     // Вычисление критерия для последовательности
        //    criteria = Criteria(mass, left, right);
        //    printf("\nЛевый индекс = %d \nПравый индекс = %d\nКритерий = %lg",
        //        left, right, criteria);
        //    break;

        case '3':     // Сортировка по убыванию
            Sorting(mass, left, right, optMin);
            ShowArray(mass, size);
            break;

        case '4':     // Сортировка по возрастанию
            Sorting(mass, left, right, optMax);
            ShowArray(mass, size);
            break;

        case '5':     // Задание левой границы
          // Изменить левую границу
            printf("\nВведите левую границу [=%d]:>", left);
            check = scanf("%d", &left);

            // Проверить корректность ввода и допустимость диапазона
            if (check != 1 || fgetchar() != 10 || left < 0 || left >= right)
            {
                // Вывести сообщение об ошибке
                Error(errArrayIndex);
                // Перейти к меню
                continue;
            }
            break;

        case '6':     // Задание правой границы
          // Изменить правую границу
            printf("\nВведите правую границу [=%d]:>", right);
            check = scanf("%d", &right);

            // Проверить корректность ввода и допустимость диапазона
            if (check != 1 || fgetchar() != 10 || right <= left || right >= size)
            {
                // Вывести сообщение об ошибке
                Error(errArrayIndex);
                // Перейти к меню
                continue;
            }
            break;

        case '7':     // Поиск оптимальной последовательности по максимуму критерия
            SearchN(mass, size, optMin, left, right, criteria);
            printf("\nЛевый индекс = %d \nПравый индекс = %d\nКритерий = %lg",
                left, right, criteria);
            break;

        case '8':     // Поиск оптимальной последовательности по максимуму критерия
            SearchCh(mass, size, optMax, left, right, criteria);
            printf("\nЛевый индекс = %d \nПравый индекс = %d\nКритерий = %lg",
                left, right, criteria);
            break;

        case '9':     // Установка границ последовательности по размеру массива
            left = 0;
            right = size - 1;
            break;

        default:
            printf("\nОшибка: Некорректная операция");
        }
        // Сбросить устройство ввода
        fflush(stdin);
        // Ввести подменю
        printf("\nОбработка последовательности [%d to %d]:", left, right);
        printf("\n1. Печатать массив");
        printf("\n2. Вычислить критерий");
        printf("\n3. Сортировать по убыванию");
        printf("\n4. Сортировать по возрастанию");
        printf("\n5. Задать левую границу последовательности");
        printf("\n6. Задать правую границу последовательности");
        printf("\n7. Искать последовательность для минимуму критерия");
        printf("\n8. Искать последовательность для максимума критерия");
        printf("\n9. Установить границы последовательности по размеру массива");
        printf("\n0. Вернуться в главное меню");
        printf("\nВыберите пункт:>");
        std::cin >> ch;
    }
    // Продолжать цикл, пока не выход
    while (ch != '0');
}
