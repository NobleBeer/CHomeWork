#include <stdio.h>    // библиотека ввода-вывода
#include "Task.h"     // описание глобальных данных и функций проекта

#pragma warning(disable: 4996)
/*
   Функция проверяет корректность имени файла (name), и
   возвращает true – если имя корректно, или false – если нет
*/
errCode CheckFileName(char* name  /* указатель на имя файла */)
{
    char ch;                 // Текущий символ
    int i;                   // Индекс символа

    // Организовать цикл для перебора символов в строке имени файла,
    // Пока не конец строки, увеличить индекс символа и получить символ 
    for (i = 0, ch = name[0]; ch != '\0'; i++, ch = name[i])
    {
        // Проверить корректность задания имени устройства
        if (ch == ':' && i != 1) return errDeviceLetter;
        // Проверить отсутствие двойных слешей в пути и слеша в конце имени
        if (ch == '\\' && (name[i + 1] == '\0' || name[i + 1] == '\\')) return errDoubleSlash;
        // Проверить отсутсвие недопустимых символов
        if (ch == '<' || ch == '>' || ch == '*' || ch == '?' || ch == '|' || ch == '\"')
            return errIllegalSymbol;
    }
    // Вернуть результат успеха
    return errOK;
}
/*  Функция сохраняет размер и элементы массива в файле
    с проверкой корректности доступа к файлу
*/
errCode SaveArrayData(double*& mass   /* ссылка на указатель на массив */,
    int& size       /* ссылка на размер */,
    char* filename  /* указатель на имя файла */)
{
    FILE* out;               // Указатель на файл

    // Открыть файл на запись и проверить результат открытия
    // Вернуть ошибку, если файл не может быть открыт или создан
    if ((out = fopen(filename, "w")) == NULL) return errCanNotOpenFile;

    // Записать в файл размер массива
    fprintf(out, "%d\n", size);

    // Организовать цикл перебора всех элементов массива
    for (int index = 0; index < size; index++)
        // Записать в файл значение элемента
        fprintf(out, "%lg\n", mass[index]);

    // Закрыть файл после записи массива
    fclose(out);
    // Вернуть результат успеха
    return errOK;
}
/*
   Функция загружает размер и элементы массива из файла,
   резервирует память под новый массив, удаляет старый
   массив, проверяет корректность чтения данных из файла
*/
errCode LoadArrayData(double*& mass   /* ссылка на указатель на массив */,
    int& size       /* ссылка на размер */,
    char* filename  /* указатель на имя файла */)
{
    double* tmpMass = NULL;  // Указатель на новый массив
    int tmpSize = 0;         // Размер нового массива
    int index;               // Индекс элементов
    FILE* in;                // Указатель на файл

    // Открыть файл на чтение и проверить результат открытия
    // Вернуть ошибку, если файл не доступен для открытия (shared)
    if ((in = fopen(filename, "r")) == NULL) return errCanNotOpenFile;

    // Прочитать размер массива и проверить корректность чтения
    // Если прочитать невозможно, то сбросить размер в ноль
    if (fscanf(in, "%d", &tmpSize) != 1) tmpSize = 0;

    // Если размер прочитан, то проверить его на допустимый диапазон
    // Вернуть ошибку, если размер некорректен
    if (!CorrectSize(tmpSize)) return errArraySize;

    // Зарезервировать память под новый массив
    tmpMass = new double[tmpSize];

    // Проверить, что память выделена
    // Вернуть ошибку, если память не выделилась
    if (tmpMass == NULL) return errNotMemory;

    // Организовать цикл для чтения всех элементов массива
    for (index = 0; index < tmpSize; index++)
    {
        // Прочитать очередной элемент и проверить корректность чтения
        if (fscanf(in, "%lg", &tmpMass[index]) != 1)
        {

            // Удалить новый массив, если чтение элемента некорректно
            delete[] tmpMass;
            // Вернуть ошибку в зависмости от того, что было при чтении:
            // Либо наткнулись на конец файла, либо некорректен сам элемент
            return ((feof(in)) ? errAbsentElements : errArrayElement);
        }
    }
    // Закрыть файл после чтения массива
    fclose(in);
    // Освободить память из под старого массива
    if (mass != NULL) delete[] mass;
    // Запомнить новый указатель и размер массива как текущий
    mass = tmpMass;
    size = tmpSize;
    // Вернуть результат успеха
    return errOK;
}
