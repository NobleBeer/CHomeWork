// Lab_8.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <stdio.h> // библиотека ввода-вывода
#include <string.h> // библиотека строковых функций
#include <io.h> // библиотека работы с файловой системой
#include <locale.h> // библиотека языковой локализации

/* Размер символьного буфера под имя файла */
#define NAMELEN 64
#pragma warning(disable: 4996)

/* Функция кодирует asci-код символа методом
перестановки полубайтов с инверсией битов
*/

unsigned char Crypt(unsigned char ch)
{
	if (ch != '\n' && ch != '\r' && ch != '\t' && ch != '\v' && ch != ' ') {
		return (((ch & 0xAA) >> 1) | ((ch & 0x55) << 1)) ^ 0xFF;
	}

}
/* Функция запрашивает у пользователя строку длин
ы не больше size
переводит ее в нижний регистр и сохраняет в массиве buffer[size]
*/

void EntryName(char* buffer, int size)
{
	fgets(buffer, size, stdin);
	*strrchr(buffer, '\n') = '\0';
	fflush(stdin);
	strlwr(buffer);
}

/* Функция проверяет корректность имени файла (name), и
возвращает true – если имя корректно, или false – если нет.
*/

bool CheckFileName(char* name)
{
	char* result;
	// Если задан диск, то он указывается в начале пути
	if (result = strchr(name, ':'))
		if ((result - name) != 1) return false;
	// Двойные слеши в пути запрещены
	if (strstr(name, "\\\\")) return false;
	// В конце пути должно быть непустое имя файла
	if (result = strrchr(name, '\\'))
		if (*(result + 1) == '\0') return false;
	// Запрещенные символы в имени или пути
	if (strpbrk(name, "\"<*?|>")) return false;
	return true;
}

/* Главная функция (Интерфейс программы)
*/

void main(int argc, char* argv[])
{
	/* Объявление буферов для имени исходного файла,
	имени файла результата и переменной для символа
	*/
	int ch;
	char sender[NAMELEN], receiver[NAMELEN];
	// Для сообщений на русском языке
	setlocale(LC_ALL, "Russian");
	printf("Лаба: Шифрование\n");
	/* Обработка командной строки в формате:
	программа.exe [Исходный_файл [Файл_результата]]
	где [ ]-обозначает, что параметр может быть не задан
	*/
	switch (argc)
	{
		// Заданы все параметры
	case 3:
		strncpy_s(sender, NAMELEN, argv[1], _TRUNCATE);
		strncpy_s(receiver, NAMELEN, argv[2], _TRUNCATE);
		break;
		// Задан исходный файл
	case 2:
		strncpy_s(sender, NAMELEN, argv[1], _TRUNCATE);
		goto m_1;
		// Ничего не задано (командная строка пустая)
	case 1:
		printf("Введите имя исходного файла:>");
		EntryName(sender, NAMELEN);
	m_1:
		printf("Введите имя файла результата:>");
		EntryName(receiver, NAMELEN);
		break;
		// Задано слишком много параметров
	default:
		printf("Формат командной строки:\nprogram.exe [source_filename [result_filename]]\n");
		getchar();
		return;
	};

	// Проверить корректность имени исходного файла
	if (!CheckFileName(sender))
	{
		printf("Ошибка: Некорректное имя исходного файла");
		getchar();
		return;
	}

	// Проверить корректность имени файла результата
	if (!CheckFileName(receiver))
	{
		printf("Ошибка: Некорректное имя файла результата");
		getchar();
		return;
	}

	// Проверить существование исходного файла
	if (_access(sender, 0) != 0)
	{
		printf("Ошибка: Исходный файл не найден");
		getchar();
		return;
	}

	// Проверить отсутствие файла результата
	if (_access(receiver, 0) == 0)
	{
		printf("Ошибка: Файл результата уже существует");
		getchar();
		return;
	}
	// Открыть исходный файл на чтение
	FILE* in = fopen(sender, "r");
	if (!in)
	{
		printf("Ошибка: Исходный файл не может быть открыт");
		getchar();
		return;
	}

	// Открыть файл результата на запись
	FILE* out = fopen(receiver, "w");
	if (!out)
	{
		printf("Ошибка: Файл результата не может быть создан");
		getchar();
		return;
	}

	printf("\nСтрат обработки файла \"%s\" в файл \"%s\"", sender, receiver);

	/* Чтение символа из исходного файла, вызов функции обработки
	кода, запись преобразованного кода в файл результата до тех
	пор, пока не конец исходного файла
	*/

	while ((ch = fgetc(in)) != EOF)
	{
		fputc(Crypt(ch), out);
	}

	// Закрыть файлы
	fclose(in);
	fclose(out);
	// Вывести сообщение о завершении

	printf("\nOK: Обработка завершена");
	getchar();
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
